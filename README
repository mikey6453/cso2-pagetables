# Multi-Level Page Table Library

## Overview
This library provides an implementation of a multi-level page table for virtual memory systems. It is configurable and adaptable for various depths of page table levels and page sizes.

## Customizing `config.h`
`config.h` is a critical file for customizing the behavior of the page table. It contains two definitions:

- `LEVELS`: This represents the number of levels in the page table. Acceptable values range from 1 to 6. Adjust this based on the required depth of your page table hierarchy.
- `POBITS`: This defines the size of page offsets, indirectly dictating the size of each page table. Acceptable values range from 4 to 18. This setting also affects the number of entries in each page table.

## Big-O Analysis

- **Time Complexity of page_allocate**: The function `page_allocate` has a time complexity of O(LEVELS), as it iterates over each level of the page table only once per level to allocate or traverse page tables. The work done at each level is constant, assuming memory allocation via `posix_memalign` takes constant time.

- **Time Complexity of translate**: Similar to `page_allocate`, `translate` also has a time complexity of O(LEVELS). It traverses each level of the page table once to find the physical address, with constant-time operations performed at each level.

- **Space Complexity**: The space complexity is largely influenced by the number of pages and page tables allocated. Each call to `page_allocate` that results in a new page or page table allocation increases the space usage linearly. Therefore, the worst-case space complexity can be considered O(N), where N is the number of unique virtual addresses that are allocated.

### Choosing Values
- **LEVELS**: Increase for deeper table structures, useful for larger virtual address spaces. More levels increase the time complexity of translations and allocations.
- **POBITS**: Increase for larger page sizes. Larger pages can reduce the number of page tables but may increase memory wastage due to internal fragmentation.

### Deallocation
While the current library effectively handles the allocation and translation of virtual to physical addresses, it does not include a function for deallocating memory. Incorporating a deallocation feature, such as a void page_deallocate(size_t va) function, could be beneficial for managing memory usage more dynamically. However, the integration of such a feature would bring substantial complexities:

Page Table Management: Deallocating memory involves more than just freeing the mapped physical memory; it requires careful management of the corresponding page table entries across multiple levels, potentially leading to the deallocation of entire page tables if they become empty.
Memory Safety Concerns: Implementing deallocation introduces risks of memory misuse, such as dangling pointers or use-after-free errors, necessitating rigorous memory tracking mechanisms.


## Known Limitations
- This implementation currently does not support concurrent access. In multi-threaded environments, care must be taken to ensure thread safety.
- Only tested extensively for single-level page tables. Multi-level tables may exhibit unexplored edge cases.

## Suggestions for Future Expansion
- Implement thread safety features.
- Optimize for memory usage and access speed, particularly for deeper page table levels.
- Include more comprehensive error handling and reporting mechanisms.
